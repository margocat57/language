
/*
    G     ::= X
    X     ::= FUNCTION*
    FUNCTION := FUNC_CALL '{' STATEMENT* '}'
    FUNC_CALL ::= "func_name" (E {, E}*)+ 
    STATEMENT :=  INIT; |  A; | IF | WHILE | RETURN; | '{'STATEMENT*'}' | E; 
    RETURN ::= "return" E;
    IF ::= "if" "(" E ")" STATEMENT ("else" STATEMENT)?
    WHILE  ::= "while" "(" E ")" STATEMENT 
    INIT  ::= V ':=' E;
    A     ::= V '=' E;

    E     ::= M{[&&, ||]M}*
    M     ::= L{[>, == ,<]L}*
    L     ::= T{[+, -]T}* 
    T     ::= D{[*, \]D}*
    D     ::= P{[^] P}* 
    P     ::= '(' E ')' | N | V | F
    N     ::= ['0' - '9']+
    V     ::= ['a' - 'z', '_']+['a' - 'z', '0' - '9', '_']*
*/

/*
TODO: сделать область видимости

Как будто стоит помечать параметры что они параметры

В асме нам важно только количество параметров!!!!
мы просто перед вызовом функции пушим их в стрек

Пишем рекурсивный обход дерева в конце if_а если видим узел := то ставим что false

*/

// Двойное копирование - плохо

// параметры функции - мы разрешаем expr или переменную
// и тогда все еще стоит вопрос по области видимости - как мы ее задаем

// А должны ли мы прообегаться с проверкой что у нас нет нулевых узлов сред токенов?

/*
ASM -  как ищем функции?
или мы сначало оходим все дерево а уже потом проставляем функции?

*/

/*
У if/else/while - обойти поддерево и все переменные которые инциализированы сделать невидимыми
Ну область видимости - следующий шаг но важный(без него асм не заведется)

Локальный и глобальный уровень(видна ли переменная сейчас - true/false)- важно для асма
Особенно для функций

Также важно подумать про ретерн и функцию для этого и того как будут связываться стэйтменты

Функции - как проверять допустимое количество параметров? требовать или прототипов

Дальше --- показ кода в пятницу, правки парсинга и начать писать бэкэнд
За чт и пт написать почти рабочий фронтенд
*/